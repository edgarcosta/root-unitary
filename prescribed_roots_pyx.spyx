#clang c
#cinclude $SAGE_LOCAL/include/flint/
#cfile all_roots_in_interval.c
#cfile power_sums.c

from cpython cimport array
import array

cdef extern from "power_sums.h":
    ctypedef struct power_sums_data_t:
        pass

    power_sums_data_t *ranger_init(int d, int lead, int *Q0, int *modlist)
    void ranger_clear(power_sums_data_t *data)
    int c_process_queue(power_sums_data_t *ps_data, int *pol,
		  int verbosity, int node_count)

cdef class process_queue:
    cdef int d, verbosity, node_count
    cdef public int count
    cdef public int k
    cdef public array.array Q0_array
    cdef int[:] Q0
    cdef public array.array Q1_array
    cdef int[:] Q1
    cdef int[:] modlist
    cdef public array.array modlist_array
    cdef int[:] lower
    cdef int[:] upper
    cdef int bounds[2]
    cdef power_sums_data_t *ps_data

    def __init__(self, int d, int n, int lead,
                 modlist, node_count, verbosity, Q):
        cdef int i
        self.d = d
        self.k = d
        self.Q0_array = array.array('i', [0,] * (d+1))
        self.Q0 = self.Q0_array
        self.Q1_array = array.array('i', [0,] * (d+1))
        self.Q1 = self.Q1_array
        self.modlist_array = array.array('i', [0,] * (d+1))
        self.modlist = self.modlist_array
        self.lower = array.array('i', [0,] * (d+1))
        self.upper = array.array('i', [0,] * (d+1))
        for i in range(d+1):
            self.modlist[i] = modlist[d-i]
            self.Q0[i] = Q[i]
            self.Q1[i] = Q[i]
            self.lower[i] = Q[i]
            self.upper[i] = Q[i]
        if verbosity == None:
            self.verbosity = -1
        else:
            self.verbosity = verbosity
        if node_count == None:
            self.node_count = -1
        else:
            self.node_count = node_count
        self.count = 0
        self.ps_data = ranger_init(d, lead, self.Q0_array.data.as_ints,
                                   self.modlist_array.data.as_ints)

    def clear(self):
        ranger_clear(self.ps_data)

    cpdef int exhaust_next_answer(self):
        return c_process_queue(self.ps_data, self.Q1_array.data.as_ints,
                               self.verbosity, self.node_count)

